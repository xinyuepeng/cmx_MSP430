#include "ADC.h"
#include "SystemData.h"

/*! \var float g_fAdcValue[5]
    \brief realtime 5 channel ADC data.
 */
#ifdef USING_INTERNAL_TEMP
float g_fAdcValue[6];
#else
float g_fAdcValue[5]; 
#endif

/*! \var ADC_BUF_BOX_DATA s_AdcBuf[5]
    \brief 5 channel for ADC data by ADC_BUF_BOX_DATA type.
 */
#ifdef USING_INTERNAL_TEMP
ADC_BUF_BOX_DATA s_AdcBuf[6]; 
#else
ADC_BUF_BOX_DATA s_AdcBuf[5];
#endif

//=================================================================================================
//                         LOCAL FUNCTION DECLEAR
//=================================================================================================
float    ADC_Average (ADC_BUF_BOX_DATA *BufBoxAdd);
BOOLEAN  ADC_BufBoxPop (float *pfPopData, ADC_BUF_BOX_DATA *BufBoxAdd);
BOOLEAN  ADC_BufBoxPush (float *pfPushData, ADC_BUF_BOX_DATA *BufBoxAdd);
void     ADC_GetAverage(void);

void ADC_Init(void)
{
    /*
    */
    //ADC12CTL1 = 0X0202;   
    ADC12CTL1 = 0X02FE;              // 0x02F2; first conv. result is stored in ADC12MEM0
                                    // ADC12SC bit triggers Sample&Hold
                                    // sample pulse is generated by Sampling Timer
                                    // Clock Source: ADC12 internal oscillator
                                    // Clock divider: 1
                                    // conversion mode: one single sequence
    
    ADC12CTL0 = 0x00F0;              // Sample&Hold Time 0
                                    // Sample&Hold Time 1 
                                    // Multiple Sample&Hold: only one sample is taken
                                    // reference voltage is on
                                    // ADC12 module is switched on 
                                    // no interrupts  
}

/*! \fn BOOLEAN  ADC_BufBoxPush (float *pfPushData, ADC_BUF_BOX_DATA *BufBoxAdd)
    \brief push a A2D data into pointed A2D queue.
    \param pfPushData a pointer to A2D data.
    \param BufBoxAdd a pointer to A2D queue.
 */
BOOLEAN  ADC_BufBoxPush (float *pfPushData, ADC_BUF_BOX_DATA *BufBoxAdd)
{
   BufBoxAdd -> fDataBuf[BufBoxAdd -> ucBoxBottom] = *pfPushData;
   BufBoxAdd -> ucBoxBottom++;
   BufBoxAdd -> ucBoxBottom %= ADC_BUF_SIZE;   

   if (BufBoxAdd -> ucBoxBottom == BufBoxAdd -> ucBoxTop)
   {
      return FALSE;
   }
   else
   {
      return TRUE;
   }
}

/*! \fn BOOLEAN  ADC_BufBoxPop (float *pfPopData, ADC_BUF_BOX_DATA *BufBoxAdd)
    \brief pop a A2D data from pointed queue
    \param pfPushData a pointer to A2D data.
    \param BufBoxAdd a pointer to A2D queue.
 */
BOOLEAN  ADC_BufBoxPop (float *pfPopData, ADC_BUF_BOX_DATA *BufBoxAdd)
{
   if (BufBoxAdd -> ucBoxBottom == BufBoxAdd -> ucBoxTop)
   {
      return FALSE;
   }
   else
   {
      *pfPopData = BufBoxAdd -> fDataBuf[BufBoxAdd -> ucBoxTop];
      BufBoxAdd -> ucBoxTop++;
      BufBoxAdd -> ucBoxTop %= ADC_BUF_SIZE;      
   }
   return TRUE;
}

/*! \fn float ADC_Average (ADC_BUF_BOX_DATA *BufBoxAdd)
    \brief count the average value of the pointed A2D queue
    \param BufBoxAdd the pointer to A2D queue.
*/
float ADC_Average (ADC_BUF_BOX_DATA *BufBoxAdd)
{
   INT8U ucCnt    = 0;
   float fDataBuf = 0;
   
   for (ucCnt = 0; ucCnt < ADC_BUF_SIZE; ucCnt++)
   {
      fDataBuf += BufBoxAdd -> fDataBuf[ucCnt];     
   }
   
   fDataBuf = fDataBuf / (float)ADC_BUF_SIZE;
   
   return fDataBuf;
}

/*! \fn void ADC_GetAverage(void)
    \brief filter the saltation.
 */
void ADC_GetAverage(void)
{
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S
   g_fAdcValue[ADC_GasA_SQ] = g_fAdcValue[ADC_GasA_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_GasA_SQ]); 
   g_fAdcValue[ADC_GasB_SQ] = g_fAdcValue[ADC_GasB_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_GasB_SQ]);      
#elif SENSOR_TYPE == SENSOR_O2
   g_fAdcValue[ADC_GasO2_SQ] = g_fAdcValue[ADC_GasO2_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_GasO2_SQ]); 
#endif
   g_fAdcValue[ADC_Temp_SQ] = g_fAdcValue[ADC_Temp_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_Temp_SQ]);
   g_fAdcValue[ADC_Vbat_SQ] = g_fAdcValue[ADC_Vbat_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_Vbat_SQ]);    
   g_fAdcValue[ADC_Vref_SQ] = g_fAdcValue[ADC_Vref_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_Vref_SQ]);   
#ifdef USING_INTERNAL_TEMP
   g_fAdcValue[ADC_TempInt_SQ] = g_fAdcValue[ADC_TempInt_SQ]*0.1 + 0.9*ADC_Average(&s_AdcBuf[ADC_TempInt_SQ]);
#endif
}

void Task_GetADC(void)
{
    float fDataBuf = 0;
    float fDataMax = 0;
    float fDataMin = 0XFFFF;
    
    ADC12CTL0  &=~ ADC_ENC;              // Disable conversion before changing the ADC12 settings!!! 
    ADC_Init();
    //ADC12CTL0  |=  REFON + ADC12ON;
    ADC12CTL0  &= ~ADC12OVIE + ADC12TOVIE;
    
    ADC12MCTL0  =  ADC_Vref_CH; 
    ADC12MCTL1  =  ADC_Vref_CH;
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S
    ADC12MCTL2  =  ADC_GasB_CH; 
    ADC12MCTL3  =  ADC_GasB_CH;             
    ADC12MCTL4  =  ADC_GasB_CH;   
    ADC12MCTL5  =  ADC_GasB_CH;   
    ADC12MCTL6  =  ADC_GasB_CH;  
    
    ADC12MCTL7  =  ADC_GasA_CH;   
    ADC12MCTL8  =  ADC_GasA_CH;  
    ADC12MCTL9  =  ADC_GasA_CH; 
    
    ADC12MCTL10 =  ADC_GasA_CH;  
    ADC12MCTL11 =  ADC_GasA_CH; 
#elif SENSOR_TYPE == SENSOR_O2
    ADC12MCTL2  =  ADC_Vref_CH;
    
    ADC12MCTL3  =  ADC_GasO2_CH;             
    ADC12MCTL4  =  ADC_GasO2_CH;   
    ADC12MCTL5  =  ADC_GasO2_CH;   
    ADC12MCTL6  =  ADC_GasO2_CH;  
    ADC12MCTL7  =  ADC_GasO2_CH;   
    ADC12MCTL8  =  ADC_GasO2_CH;  
    ADC12MCTL9  =  ADC_GasO2_CH; 
    ADC12MCTL10 =  ADC_GasO2_CH;  
    
    #ifdef USING_INTERNAL_TEMP   
        ADC12MCTL11 =  ADC_Temp_Int_CH;  
    #else   
        ADC12MCTL11 =  ADC_Temp_CH;  
    #endif
#endif
    
#ifdef USING_INTERNAL_TEMP   
    ADC12MCTL12 =  ADC_Temp_Int_CH;  
    ADC12MCTL13 =  ADC_Temp_Int_CH;  
#else   
    ADC12MCTL12 =  ADC_Temp_CH;  
    ADC12MCTL13 =  ADC_Temp_CH;  
#endif
    
    ADC12MCTL14 =  ADC_Vbat_CH;  
    ADC12MCTL15 =  ADC_Vbat_CH + 0x80;   // ADC12MCTL15 is end of sequence  (EOS bit is set!)
    
    
    ADC12CTL0 |= ADC_ENC;               // enable conversion
    
    ADC12CTL0 |= ADC_SC;                // start sampling
    ADC12CTL0 &=~ADC_SC;                // COLSE sampling
    
    while ((ADC12IFG & 0x8000) == 0);   // wait until interrupt flag 15 is set
                                       // whole sequence is finished
    
    ADC12CTL0  &=~ ADC_ENC;              // Disable conversion before changing the ADC12 settings!!!    
    ADC12CTL0  &=~ (REFON + ADC12ON); 
    
    //ADC_Vref_CH
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S
    fDataBuf = (float)ADC12MEM0 + (float)ADC12MEM1;
    fDataBuf = fDataBuf / 2.0;
#elif SENSOR_TYPE == SENSOR_O2
    fDataBuf = (float)ADC12MEM0 + (float)ADC12MEM1 + (float)ADC12MEM2;
    fDataBuf = fDataBuf / 3.0;
#endif   
    ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_Vref_SQ]);
    
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S   
    //ADC_GasB_CH
    fDataMax = 0;
    fDataMin = 0XFFFF;   
    
    if ((float)ADC12MEM2 > fDataMax) fDataMax = (float)ADC12MEM2;
    if ((float)ADC12MEM2 < fDataMin) fDataMin = (float)ADC12MEM2;
    
    if ((float)ADC12MEM3 > fDataMax) fDataMax = (float)ADC12MEM3;
    if ((float)ADC12MEM3 < fDataMin) fDataMin = (float)ADC12MEM3;
    
    if ((float)ADC12MEM4 > fDataMax) fDataMax = (float)ADC12MEM4;
    if ((float)ADC12MEM4 < fDataMin) fDataMin = (float)ADC12MEM4;
    
    if ((float)ADC12MEM5 > fDataMax) fDataMax = (float)ADC12MEM5;
    if ((float)ADC12MEM5 < fDataMin) fDataMin = (float)ADC12MEM5;
         
    if ((float)ADC12MEM6 > fDataMax) fDataMax = (float)ADC12MEM6;
    if ((float)ADC12MEM6 < fDataMin) fDataMin = (float)ADC12MEM6;
        
    /* 5 channel, remove one max and one min, then get average value.
    */
    fDataBuf = (float)ADC12MEM2 + (float)ADC12MEM3 + (float)ADC12MEM4;
    fDataBuf = fDataBuf + (float)ADC12MEM5 + (float)ADC12MEM6 ;
    fDataBuf = (fDataBuf - fDataMax - fDataMin)/ 3.0;
    ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_GasB_SQ]);   
#endif
    
    //ADC_GasA_CH
    fDataMax = 0;
    fDataMin = 0XFFFF;
#if SENSOR_TYPE == SENSOR_O2
    if ((float)ADC12MEM3 > fDataMax) fDataMax = (float)ADC12MEM3;
    if ((float)ADC12MEM3 < fDataMin) fDataMin = (float)ADC12MEM3;
    
    if ((float)ADC12MEM4 > fDataMax) fDataMax = (float)ADC12MEM4;
    if ((float)ADC12MEM4 < fDataMin) fDataMin = (float)ADC12MEM4;
    
    if ((float)ADC12MEM5 > fDataMax) fDataMax = (float)ADC12MEM5;
    if ((float)ADC12MEM5 < fDataMin) fDataMin = (float)ADC12MEM5;
         
    if ((float)ADC12MEM6 > fDataMax) fDataMax = (float)ADC12MEM6;
    if ((float)ADC12MEM6 < fDataMin) fDataMin = (float)ADC12MEM6;
#endif   
    if ((float)ADC12MEM7 > fDataMax) fDataMax = (float)ADC12MEM7;
    if ((float)ADC12MEM7 < fDataMin) fDataMin = (float)ADC12MEM7;
    
    if ((float)ADC12MEM8 > fDataMax) fDataMax = (float)ADC12MEM8;
    if ((float)ADC12MEM8 < fDataMin) fDataMin = (float)ADC12MEM8;
    
    if ((float)ADC12MEM9 > fDataMax) fDataMax = (float)ADC12MEM9;
    if ((float)ADC12MEM9 < fDataMin) fDataMin = (float)ADC12MEM9;
    
    if ((float)ADC12MEM10 > fDataMax) fDataMax = (float)ADC12MEM10;
    if ((float)ADC12MEM10 < fDataMin) fDataMin = (float)ADC12MEM10;
    
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S          
    if ((float)ADC12MEM11 > fDataMax) fDataMax = (float)ADC12MEM11;
    if ((float)ADC12MEM11 < fDataMin) fDataMin = (float)ADC12MEM11;   
    
    /* same as channel GasB
    */
    fDataBuf = (float)ADC12MEM7 + (float)ADC12MEM8 + (float)ADC12MEM9;
    fDataBuf = fDataBuf + (float)ADC12MEM10 + (float)ADC12MEM11;
    fDataBuf = (fDataBuf - fDataMax - fDataMin)/ 3.0;
    ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_GasA_SQ]);  
#elif SENSOR_TYPE == SENSOR_O2
    fDataBuf = (float)ADC12MEM3 + (float)ADC12MEM4 + (float)ADC12MEM5;
    fDataBuf = fDataBuf + (float)ADC12MEM6 + (float)ADC12MEM7;
    fDataBuf = fDataBuf - fDataMax - fDataMin;
    fDataBuf = fDataBuf + (float)ADC12MEM8 + (float)ADC12MEM9;
    fDataBuf = (fDataBuf + (float)ADC12MEM10)/6.0;
    ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_GasO2_SQ]);  
#endif   
     
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S     
    #ifdef USING_INTERNAL_TEMP  
       fDataBuf = (float)ADC12MEM12 + (float)ADC12MEM13;
       fDataBuf = fDataBuf / 2.0;
       ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_TempInt_SQ]);
    #else
       //ADC_Temp_CH
       fDataBuf = (float)ADC12MEM12 + (float)ADC12MEM13;
       fDataBuf = fDataBuf / 2.0;
       ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_Temp_SQ]);
    #endif
#elif SENSOR_TYPE == SENSOR_O2
    #ifdef USING_INTERNAL_TEMP  
       fDataBuf = (float)ADC12MEM11 + (float)ADC12MEM12 + (float)ADC12MEM13;
       fDataBuf = fDataBuf / 3.0;
       ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_TempInt_SQ]);
    #else
       //ADC_Temp_CH
       fDataBuf = (float)ADC12MEM11 + (float)ADC12MEM12 + (float)ADC12MEM13;
       fDataBuf = fDataBuf / 3.0;
       ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_Temp_SQ]);
    #endif
#endif   
    //ADC_Vbat_CH
    fDataBuf = (float)ADC12MEM14 + (float)ADC12MEM15;
    fDataBuf = fDataBuf / 2.0;
    ADC_BufBoxPush(&fDataBuf, &s_AdcBuf[ADC_Vbat_SQ]); 
}

void Task_GasReading(void)
{
    /*! \var  static INT8U s_ucMeasureRange
    
        it is local global varible, used to control the current measure range.
    */
    static INT8U s_ucMeasureRange = 0;
    float  fDataBuf               = 0;
    
    ADC_GetAverage();
#if SENSOR_TYPE == SENSOR_CO || SENSOR_TYPE == SENSOR_H2S
    switch (s_ucMeasureRange)
    {
      case 0xFF: // 0 - measure range
         fDataBuf =  g_fAdcValue[ADC_GasA_SQ];
         fDataBuf = (fDataBuf - g_fSenZeroHi) / g_fSenSpanHi;          
         break;
      default:   // 0 - alternate
         fDataBuf =  g_fAdcValue[ADC_GasB_SQ];
         fDataBuf = (fDataBuf - g_fSenZero ) / g_fSenSpan;
         break;
    }
    
    fDataBuf = fDataBuf / g_fTempCoef;   
    if ((fDataBuf > -1.8    ) && ( fDataBuf < 1.8)) { fDataBuf = 0.0; }
    if ( fDataBuf < -3.0    ) { fDataBuf = (fDataBuf + 3.0) * 0.1 - 3.0;}   
    
    g_fGasCurVal = fDataBuf + 0.05;
    
    /*
     According the current reading value, switch measure range.
    */
    if (( g_fGasCurVal > RANG_ALT_HI ) && ( s_ucMeasureRange == 0    ))
    {
      s_ucMeasureRange = 0XFF;     
    } 
    
    if (( g_fGasCurVal < RANG_ALT_LO ) && ( s_ucMeasureRange == 0XFF ))
    {
      s_ucMeasureRange = 0 ;
    }
    #elif SENSOR_TYPE == SENSOR_O2
    fDataBuf =  g_fAdcValue[ADC_GasO2_SQ];
    fDataBuf = (fDataBuf) / g_fSenSpan; 
    fDataBuf = fDataBuf / g_fTempCoef; 
    if(fDataBuf > 30.0)  fDataBuf = 30;
    if(fDataBuf < -10.0) fDataBuf = -10;
    g_fGasCurVal = fDataBuf;
    //   g_fGasCurVal = fDataBuf +     2;
    #endif   
    if ( g_uiGasPeak  < g_fGasCurVal ) g_uiGasPeak = g_fGasCurVal;
}